<!doctype html><html lang='en'><head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<title>Pathfinding</title><link rel='stylesheet' href='../../assets/css/style.css'></head><body>
<header class='nav'><div class='container'><a class='brand' href='../../index.html'><- Back</a><div class='badge'>Grid</div></div></header>
<section class='container prose'>
  <h2>Pathfinding</h2>
  <p><strong>What you see:</strong> a grid with start (green) and goal (red). Walls are dark blocks. The algorithm draws a blue route.</p>
  <p><strong>How to use:</strong> click to place/remove walls; choose A* or Dijkstra; press Run; drag start/goal if you want.</p>
  <div class='center'><img src='../../assets/images/preview_path.png' alt='Preview' class='img-frame' style='max-width:100%;height:auto;margin-bottom:10px'></div>
  <div class='controls'><button class='btn' id='reset'>Reset</button><button class='btn' id='walls'>Toggle Walls</button><select id='algo'><option value='astar'>A*</option><option value='dijkstra'>Dijkstra</option></select><button class='btn' id='run'>Run</button><span class='kpi'>Explored: <span id='kExplored'>0</span></span><span class='kpi'>Path: <span id='kLen'>0</span></span></div>
  <div class='center'><canvas id='grid' width='720' height='540' class='img-frame'></canvas></div>
  <h3>Notes</h3>
  <ul><li>Explored = cells checked</li><li>Path = steps in the final route</li></ul>
</section>
<footer><div class='container'>Contact: <a href='mailto:ambrosetheshield6@gmail.com'>ambrosetheshield6@gmail.com</a></div></footer>
<script>const canvas=document.getElementById('grid'),ctx=canvas.getContext('2d');const kExplored=document.getElementById('kExplored'), kLen=document.getElementById('kLen');const W=36,H=27,S=20; let walls=new Set(); let dragging=null; let makingWalls=false;let start={x:3,y:3}, goal={x:32,y:22};
function key(x,y){return x+','+y}
function draw(){ctx.clearRect(0,0,canvas.width,canvas.height);ctx.fillStyle='#0f1526'; ctx.fillRect(0,0,canvas.width,canvas.height);ctx.strokeStyle='#1a2240';
for(let x=0;x<=W;x++){ctx.beginPath();ctx.moveTo(x*S,0);ctx.lineTo(x*S,H*S);ctx.stroke()}
for(let y=0;y<=H;y++){ctx.beginPath();ctx.moveTo(0,y*S);ctx.lineTo(W*S,y*S);ctx.stroke()}
ctx.fillStyle='#1f335f'; walls.forEach(k=>{const a=k.split(',');const x=parseInt(a[0]);const y=parseInt(a[1]); ctx.fillRect(x*S+1,y*S+1,S-2,S-2)});
ctx.fillStyle='#37f26e'; ctx.fillRect(start.x*S+3,start.y*S+3,S-6,S-6);
ctx.fillStyle='#f23737'; ctx.fillRect(goal.x*S+3,goal.y*S+3,S-6,S-6);}
canvas.addEventListener('mousedown',function(e){const r=canvas.getBoundingClientRect(); const x=Math.floor((e.clientX-r.left)/S), y=Math.floor((e.clientY-r.top)/S);
  if(x===start.x&&y===start.y) dragging='start'; else if(x===goal.x&&y===goal.y) dragging='goal'; else {makingWalls=true; toggleWall(x,y)} draw();});
canvas.addEventListener('mousemove',function(e){const r=canvas.getBoundingClientRect(); const x=Math.floor((e.clientX-r.left)/S), y=Math.floor((e.clientY-r.top)/S); if(dragging==='start'){start={x:x,y:y}; draw()} else if(dragging==='goal'){goal={x:x,y:y}; draw()} else if(makingWalls){toggleWall(x,y); draw()}});
window.addEventListener('mouseup',function(){dragging=null; makingWalls=false});
function toggleWall(x,y){ if(x<0||x>=W||y<0||y>=H) return; const k=key(x,y); if(walls.has(k)) walls.delete(k); else walls.add(k) }
function neighbors(n){const dirs=[[1,0],[-1,0],[0,1],[0,-1]]; const res=[]; for(var i=0;i<dirs.length;i++){var dx=dirs[i][0],dy=dirs[i][1];const x=n.x+dx,y=n.y+dy; if(x>=0&&x<W&&y>=0&&y<H&&!walls.has(key(x,y))) res.push({x:x,y:y})} return res}
function heur(a,b){return Math.abs(a.x-b.x)+Math.abs(a.y-b.y)}
function run(algo){const open=[start]; const g=new Map([[key(start.x,start.y),0]]); const came=new Map(); const f=new Map([[key(start.x,start.y),heur(start,goal)]]);const seen=new Set([key(start.x,start.y)]); let explored=0;
  while(open.length){open.sort(function(u,v){return (f.get(key(u.x,u.y))||1e9)-(f.get(key(v.x,v.y))||1e9)});const cur=open.shift(); explored++; if(cur.x===goal.x&&cur.y===goal.y){kExplored.textContent=explored; return reconstruct(came,cur);}
    const nbs=neighbors(cur); for(var i=0;i<nbs.length;i++){const nb=nbs[i];const k=key(nb.x,nb.y), kc=key(cur.x,cur.y);const tent=(g.get(kc)||0)+1;if(!g.has(k)||tent<g.get(k)){came.set(k,kc); g.set(k,tent);let pr=tent+(algo==='astar'?heur(nb,goal):0);f.set(k,pr); if(!seen.has(k)){open.push(nb); seen.add(k)}}}}
  kExplored.textContent=explored; return []}
function reconstruct(came,cur){const path=[cur]; let k=key(cur.x,cur.y);while(came.has(k)){k=came.get(k); const a=k.split(','); path.push({x:parseInt(a[0]),y:parseInt(a[1])})}kLen.textContent=path.length; return path.reverse()}
function animate(path){draw(); ctx.fillStyle='#5ea0ff';let i=0; const id=setInterval(function(){ if(i>=path.length){clearInterval(id); return} const p=path[i++]; ctx.fillRect(p.x*S+4,p.y*S+4,S-8,S-8); },16);}
document.getElementById('reset').onclick=function(){walls.clear(); start={x:3,y:3}; goal={x:32,y:22}; kExplored.textContent='0'; kLen.textContent='0'; draw()};
document.getElementById('walls').onclick=function(){makingWalls=!makingWalls};
document.getElementById('run').onclick=function(){const algo=document.getElementById('algo').value; const path=run(algo); animate(path)};
draw();</script>
</body></html>